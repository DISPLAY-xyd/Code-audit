# 逆向工程

#### 寄存器

​		在X86寄存器中，分为 （4大类）：通用寄存器、指令指针寄存器、段寄存器、标志寄存器。

​		通用寄存器（32位）：数据寄存器、指针变址寄存器

##### 	数据寄存器：

​			EAX	EBX 	ECX		EDX

##### 	指针变址寄存器：

​			EBP 	ESP	ESI	EDI

##### 	数据寄存器：

​			EAX(Accumulator)：累加寄存器，相对于其他寄存器，在运算方面比较常用。

​			EBX(Base)：基地址寄存器，作为内存偏移指针使用。

​			ECX(Count)：计数器，用于特定的技术。

​			EDX(Data)：作为EAX的溢出寄存器，（除法产生的余数）。

##### 	指针变址寄存器：

​			EBP(Base Pointer)：扩展基址指针寄存器，SS段中堆栈内数据指针。EBP由高级语言用来引用参数和局部变量，通常称为堆栈基址指针寄存器。

​			ESP(Stack Pointer)：堆栈指针寄存器，SS段中堆栈指针。ESP用来寻址堆栈上的数据，ESP寄存器一般不参与算数运算。

​			ESI(Source Index)：源变址寄存器，字符串操作源指针

​			EDI(Destination Index)：目的指针寄存器，字符串操作目标指针

##### 	指令指针寄存器：

​			EIP(Instruction Pointer)：指令指针寄存器，保存着下一条要执行的指令的地址。程序运行时，CPU会读取EIP中的一条指令的地址，传送指令到指令缓冲区后，EIP寄存器的值自动增加，增加的大小即是读取指令的字节大小，即下一条指令的地址为当前指令的地址加上当前指令的长度。

##### 	段寄存器：

​			CS(Code Segment)	代码段

​			DS(Data Segment)	数据段

​			SS(Stack Segment)	堆栈段‘

​			ES(Extra Segment)	附加数据段

​			FS			附加数据段

​			GS			附加数据段

##### 	标志寄存器：

​			FLAGS（flags)或PSW    标志寄存器		程序状态字寄存器

​		标志寄存器 又分为两类：条件标志寄存器、控制标志寄存器		

##### 	条件标志寄存器：

​		OF(OverFlow Flag)	溢出标志位	用来反应有符号数加减法运算所得结果是否溢出。运算超出当前运算位数所能表示的范围，则称为溢出，标志位被置为		1，否则为0。

​		SF(Sign Flag)	符号标志位	用来反应运算结果是否为0。运算结果为负时置为1，否则为0。	

​		ZF(Zero Flag)	零标志位	用来反应运算结果是否为0。为零时置为1，否则为0。

​		AF(Auxilliary carry Flag)	辅助进位标志位	在字操作址，发生低字节向高字节进位或借位时该标志位被置为1，否则为0。

​		PF(Parity Flag)	奇偶标志位	用于反应结果中“1”的个数的奇偶性。如果“1”为偶数置为1，否则为0。

​		CF(Carry Flag)	进位标志位	运算结果的最高位产生了一个进位或错位，则该标志位置为1，否则为0。

##### 		控制标志寄存器：

​		DF(Direction Flag)	方向标志位	用于串操作指令中，控制地址的变化方向。当DF为0时，存储器地址自动增加;当 DF为1时，存储器地址自动减少。

​		IF(Interupt Flag)	中断标志位	用于控制外部可屏蔽中断是否可以被处理器响应。

​		TF(Trap Flag)	陷阱标志位	用于控制处理器是否进入单步操作方式。当TF为0时，处理器在正常模式下运行；当为1时，处理器单步执行指令，调试器可以逐			步指令进行执行就是使用了该标志位。

​		

##### 	寄存器和栈的关系

​		**内存是CPU和硬盘之间的通道.**

​		**内存如同一个仓库，堆，栈是仓库中开辟的一个规则有序的仓库区，而寄存器就是生产线上的一个容器。**

​		堆，栈是属于内存区的一部分，堆，栈是内存中的一种数据结构.**

​		**而寄存器则是CPU中的一部分。寄存器是CPU的存储器.速度快.**





​	(32位） PWM常用寄存器  ESP、EBP、EIP。
​	ESP : 用来存储函数调用栈的栈顶地址，在压栈和退栈时发生变化
​	EBP : 用来存储当前函数状态的基地址，在函数运行时不变，可以用来索引确定函数参数或局部变量的位置
​	EIP : 用来存储即将执行的程序指令的地址

![image-20210702094953376](.\image\image-20210702094953376.png)





32位X86架构下汇编指令有两种格式intel与AT&T。

>Intel:寄存器名称和数值前无符号AT&T:寄存器名称前加“%”，数值前加“$”在.gdbinit配置文件中可以配置: set disassembly-flavor intel





mov  		数据传输指令，将 SRC传至 DST，格式为      MOV DST,SRC;

push	 	压入堆栈指令，将SRC压入栈内，格式为        PUSH SRC;

pop	   	弹出堆栈指令，将栈顶的数据弹出并存至DST，格式为:     POP DST;

lea			取地址指令，将MEM的地址存至REG ,格式为:      LEA REG,MEM;

add/sub 	加减法指令，将运算结果存到DST格式         ADD/SUB DST,SRC;

call			调用指令，将当前的eip压入栈顶，并将 PTR存入eip，格式为:call ptr

size         乘积 



#### 数据传输指令

##### 	通用数据传送指令		

​    MOV     传送字或字节.  
​    MOVSX   先符号扩展,再传送.  
​    MOVZX   先零扩展,再传送.  
​    PUSH    把字压入堆栈.  
​    POP     把字弹出堆栈.  
​    PUSHA   把AX,CX,DX,BX,SP,BP,SI,DI依次压入堆栈.  
​    POPA    把DI,SI,BP,SP,BX,DX,CX,AX依次弹出堆栈.  
​    PUSHAD  把EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI依次压入堆栈.  
​    POPAD   把EDI,ESI,EBP,ESP,EBX,EDX,ECX,EAX依次弹出堆栈.  
​    BSWAP   交换32位寄存器里字节的顺序  
​    XCHG    交换字或字节.(至少有一个操作数为寄存器,段寄存器不可作为操作数)  
​    CMPXCHG 比较并交换操作数.(第二个操作数必须为累加器AL/AX/EAX)  
​    XADD    先交换再累加.(结果在第一个操作数里)  
​    XLAT    字节查表转换.----BX指向一张256字节的表的起点,
​            AL为表的索引值(0-255,即0-FFH);
​            返回AL为查表结果.([BX+AL]->AL)  

##### 输入输出端口传送指令

​    IN      I/O端口输入. ( 语法: IN   累加器,    {端口号│DX} )  
​    OUT     I/O端口输出. ( 语法: OUT {端口号│DX},累加器 )
​                        输入输出端口由立即方式指定时,其范围是 0-255; 
​                        由寄存器 DX 指定时,其范围是 0-65535.  

##### 目的地址传送指令

​    LEA     装入有效地址.例: LEA DX,string ;把偏移地址存到DX.  
​    LDS     传送目标指针,把指针内容装入DS.例: LDS SI,string ;把段地址:偏移地址存到DS:SI.  
​    LES     传送目标指针,把指针内容装入ES.例: LES DI,string ;把段地址:偏移地址存到ES:DI.  
​    LFS     传送目标指针,把指针内容装入FS.例: LFS DI,string ;把段地址:偏移地址存到FS:DI.  
​    LGS     传送目标指针,把指针内容装入GS.例: LGS DI,string ;把段地址:偏移地址存到GS:DI.  
​    LSS     传送目标指针,把指针内容装入SS.例: LSS DI,string ;把段地址:偏移地址存到SS:DI.  

##### 标志传送指令

​    LAHF    标志寄存器传送,把标志装入AH.  
​    SAHF    标志寄存器传送,把AH内容装入标志寄存器.  
​    PUSHF   标志入栈.  
​    POPF    标志出栈.  
​    PUSHD   32位标志入栈.  
​    POPD    32位标志出栈.  

#### 算数运算指令

​    ADD     加法.  
​    ADC     带进位加法.  
​    INC     加 1.  
​    AAA     加法的ASCII码调整.  
​    DAA     加法的十进制调整.  
​    SUB     减法.  
​    SBB     带借位减法.  
​    DEC     减 1.  
​    NEG     求反(以    0 减之).  
​    CMP     比较.(两操作数作减法,仅修改标志位,不回送结果).  
​    AAS     减法的ASCII码调整.  
​    DAS     减法的十进制调整.  
​    MUL     无符号乘法.结果回送AH和AL(字节运算),或DX和AX(字运算),  
​    IMUL    整数乘法.结果回送AH和AL(字节运算),或DX和AX(字运算),  
​    AAM     乘法的ASCII码调整.  
​    DIV     无符号除法.结果回送:商回送AL,余数回送AH, (字节运算);或 商回送AX,余数回送DX, (字运算).  
​    IDIV    整数除法.结果回送:商回送AL,余数回送AH, (字节运算);或 商回送AX,余数回送DX, (字运算).  
​    AAD     除法的ASCII码调整.  
​    CBW     字节转换为字. (把AL中字节的符号扩展到AH中去)  
​    CWD     字转换为双字. (把AX中的字的符号扩展到DX中去)  
​    CWDE    字转换为双字. (把AX中的字符号扩展到EAX中去)  
​    CDQ     双字扩展. (把EAX中的字的符号扩展到EDX中去)  

​    DS:SI   源串段寄存器 :源串变址.  
​    ES:DI   目标串段寄存器:目标串变址.  
​    CX      重复次数计数器.  
​    AL/AX   扫描值.  
​    D标志    0表示重复操作中SI和DI应自动增量; 1表示应自动减量.  
​    Z标志    用来控制扫描或比较操作的结束.  

#### 逻辑运算指令

​    AND     与运算.  
​    OR      或运算.  
​    XOR     异或运算.  
​    NOT     取反.  
​    TEST    测试.(两操作数作与运算,仅修改标志位,不回送结果).  
​    SHL     逻辑左移.  
​    SAL     算术左移.(=SHL)  
​    SHR     逻辑右移.  
​    SAR     算术右移.(=SHR)  
​    ROL     循环左移.  
​    ROR     循环右移.  
​    RCL     通过进位的循环左移.  
​    RCR     通过进位的循环右移.  
​              以上八种移位指令,其移位次数可达255次.  
​              移位一次时, 可直接用操作码. 如 SHL AX,1.  
​              移位>1次时, 则由寄存器CL给出移位次数.  
​              如 MOV CL,04   SHL AX,CL  

#### 串指令

​    MOVS    串传送.( MOVSB 传送字符. MOVSW 传送字. MOVSD 传送双字. )  
​    CMPS    串比较.( CMPSB 比较字符. CMPSW 比较字. )  
​    SCAS    串扫描.把AL或AX的内容与目标串作比较,比较结果反映在标志位.  
​    LODS    装入串.把源串中的元素(字或字节)逐一装入AL或AX中.
​            ( LODSB 传送字符. LODSW 传送字.    LODSD 传送双字. )  
​    STOS    保存串.是LODS的逆过程.  
​    REP         当CX/ECX<>0时重复.  
​    REPE/REPZ   当ZF=1或比较结果相等,且CX/ECX<>0时重复.  
​    REPNE/REPNZ 当ZF=0或比较结果不相等,且CX/ECX<>0时重复.  
​    REPC        当CF=1且CX/ECX<>0时重复.  
​    REPNC       当CF=0且CX/ECX<>0时重复.  

#### 程序转移指令

##### 无条件转移指令(长转移)

​    JMP         无条件转移指令  
​    CALL        过程调用  
​    RET/RETF    过程返回
 条件转移指令
 			（短转移，-128到+127的距离内，当且仅当  [SF XOR OF = 1 ,OP1  < OP2）
  	JA/JNBE     不小于或不等于时转移.  
​    JAE/JNB     大于或等于转移.  
​    JB/JNAE     小于转移.  
​    JBE/JNA     小于或等于转移.  
​        以上四条,测试无符号整数运算的结果(标志C和Z).  
​    JG/JNLE     大于转移.  
​    JGE/JNL     大于或等于转移.  
​    JL/JNGE     小于转移.  
​    JLE/JNG     小于或等于转移.  
​        以上四条,测试带符号整数运算的结果(标志S,O和Z).  
​    JE/JZ       等于转移.  
​    JNE/JNZ     不等于时转移.  
​    JC          有进位时转移.  
​    JNC         无进位时转移.  
​    JNO         不溢出时转移.  
​    JNP/JPO     奇偶性为奇数时转移.  
​    JNS         符号位为 "0" 时转移.  
​    JO          溢出转移.  
​    JP/JPE      奇偶性为偶数时转移.  
​    JS          符号位为 "1" 时转移.  

##### 循环控制指令（短转移）

​    LOOP            CX不为零时循环.  
​    LOOPE/LOOPZ     CX不为零且标志Z=1时循环.  
​    LOOPNE/LOOPNZ   CX不为零且标志Z=0时循环.  
​    JCXZ            CX为零时转移.  
​    JECXZ           ECX为零时转移.  

##### 中断指令

​    INT         中断指令  
​    INTO        溢出中断  
​    IRET        中断返回  

##### 处理器控制指令

​    HLT         处理器暂停,  直到出现中断或复位信号才继续.  
​    WAIT        当芯片引线TEST为高电平时使CPU进入等待状态.  
​    ESC         转换到外处理器.  
​    LOCK        封锁总线.  
​    NOP         空操作.  
​    STC         置进位标志位.  
​    CLC         清进位标志位.  
​    CMC         进位标志取反.  
​    STD         置方向标志位.  
​    CLD         清方向标志位.  
​    STI         置中断允许位.  
​    CLI         清中断允许位.  

#### 伪指令

​    DW          定义字(2字节).  
​    PROC        定义过程.  
​    ENDP        过程结束.  
​    SEGMENT     定义段.  
​    ASSUME      建立段寄存器寻址.  
​    ENDS        段结束.  
​    END         程序结束.  



#### 栈帧

​	![image-20210702104209064](.\image\image-20210702104209064.png)

​		

​		栈帧就是一个函数执行的环境︰
​		函数参数、函数的局部变量、函数执行完后返回到哪里等等。
​		每一个栈帧代表的就是一个未运行完的函数

 

段寄存器

​		段寄存器就是提供段地址的

​		8086CPU 有4个寄存器:	CS 	DS	SS	ES	

​		当8086CPU要访问内存时，由这4个段寄存器提供内存单元的段地址

​	CS和IP寄存器  （8086都是16位）	

​		CS和IP是8086CPU中最关键的寄存器，他们指示了CPU当前要读取指令的地址

​			CS为代码段寄存器；

​			IP为指令寄存器



​	8086 PC工作的过程

​	8086 Pc读取和执行指令相关流程

#### 	 8086 PC工作过的的描述

​		1、从CS:IP指向内存单元读取指令，读取的指令进入指令缓冲器;

​		2、P = IP ＋所读取指令的长度，从而指向下一条指令;

​		3、执行指令。转到步骤1，重复这个过程。

​			在8086CPU加电启动或复位后（即CCPU刚开始工作时）cs和IP被设置为CS=FFFFH，IP=0000H，即在8086Pc机刚启动时，CPU从内存FFFFOH单元

​			中读取指令执行，FFFFOH单元中的指令是8086Pc机开机后执行的第一条指令。改变cs和IP的值就可以控制cPt的执行的指令



​		CPU将  CS:IP  指向的内存单元中的内容看作指令。

#### 			修改cs和IP的指令

​				在CPU中，能够用指令读写的部件只有寄存器，可以通过改变寄存器中的内容实现对CPU的控制。

​				可以通过改变cs、IP中的内容来控制CPU执行目标指令。

​				同时修改cs、IP的内容:

​				jmp 段地址:偏移地址

​				jmp 2AE3:3      =>    2AE3H *16 + 3 =2AE33H

#### 		修改cs和IP的指令

​		在CPU中，能够用指令读写的部件只有寄存器，可以通过改变寄存器中的内容实现对CPU的控制。

​		可以通过改变cs、IP中的内容来控制CPU执行目标指令。

​		同时修改cs、IP的内容:

​		jmp段地址:偏移地址

​			ejmp 2AE3:3      =>    2AE3H *16 + 3 =2AE33H

​			jmp 3:0B16      =>     3*16+0B16=0B46H

​			功能:用指令中给出的段地址修改cs，偏移地址修改IP。

​		仅修改IP的内容:

​			jmp某一合法寄存器

​			jmp ax(类似于mov IP,ax)jmp bx

​			功能:用寄存器中的值修改IP。



​	初始：CS=2000H  	IP =0000H

####   	代码段

​			对于8086PC机，在编程时，可以根据需要，将一组内存单元定义为一个段。可以将长度为 N（ N≤64KB ）的一组代码，存在一组地址连续、起始地址为 			16的倍数的内存单元中，这段内存是用来存放代码的，从而定义了一个代码段。

​			如何使得代码段中的指令被执行呢？

​			将一段内存当作代码段，仅仅是我们在编程时的一种安排，CPU 并不会由于这种安排，就自动地将我们定义得代码段中的指令当作指令来执行。

​			CPU 只认被 CS:IP 指向的内存单元中的内容为指令。

​			所以要将CS:IP指向所定义的代码段中的第一条指令的首地址。

​		

#### 

​	![image-20210705093112622](.\image\image-20210705093112622.png)

​	



执行顺序：

（1）mov ax,6622

（2）jmp 1000:3

（3）mov ax,0000

（4）mov bx,ax

（5）jmp bx

（6）mov ax,0123H

（7）转到第（3）步执行

这是个无限死循环的执行过程，如CPU满载.....

#### dbug指令

​	r	查看和修改寄存器的值

​		r	查看寄存器的值
​		r 	ax (cs ip等)修改寄存器a x(cs ip等)的值

​	d	查看内存中内容
​		d	1000 :01f		(1f表示范围)
​	e 	修改内存的内容
​		e 1000:0	30 	31 	32	 33 	34 	35	 36 	37(一次性修改)

​		e 1000:o'a''b''c'
​		e 1000 :0				(询问式修改)
​	u	以汇编指令的形式查看机器码
​		u	1000: 01f			(1f表示范围)



写入指令:

​	方式1:	e 1000:0b8 01 00 b9 02 00 01 08

​	方式2:	a 1000 :0						以汇编指令的形式写入

​	

​	t 	执行下一条指令(执行之前可以通过r命令修改 cs:ip 的值)

#### 寄存器（内存访问）

##### 内存中字的存储

​	在0地址处开始存放20000：

​		![image-20210705105919039](.\image\image-20210705105919039.png)

​	0号单元是低地址单元，1号单元是高地址单元。

​	任何两个地址连续的内存单元，N号单元和 N+1号单元，可以将它们看成两个内存单元 ，也可以看成一个地址为N的字单元中的高位字节单元和低位字节单元。

##### DS和[address]

​	CPU要读取一个内存单元的时候，必须先给出这个内存单元的地址；

​	在8086PC中，内存地址由段地址和偏移地址组成。

​	8086CPU中有一个 DS寄存器，通常用来存放要访问的数据的段地址。

​	例如：	我们要读取10000H单元的内容可以用如下程序段进行：

​     	mov bx,1000H

​     	mov ds,bx

​     	mov al,[0]

​		上面三条指令将10000H（1000:0）中的数据读到al中。

​			

​	mov al,[0]

​	已知的mov指令可完成的两种传送功能：

​	（1）将数据直接送入寄存器；

​	（2）将一个寄存器中的内容送入另一个寄存器中。

  	mov 指令 还可以将一个内存单元中的内容送入一个寄存器。

​	  mov指令的格式：

​      mov 寄存器名，内存单元地址

​	  “[…]”表示一个内存单元， “[…]”中的0表示内存单元的偏移地址。

​		

​	问题：

  	写几条指令，将al中的数据送入内存单元10000H？

​	分析问题本质：

​		怎样将数据从寄存器送入内存单元？

​	结论：

​			   mov bx,1000H

​       		mov ds,bx

​       		mov [0],al  

##### 字的传送

​		因为8086CPU是16位结构，有16根数据线，所以，可以一次性传送16位的数据，也就是一次性传送一个字

​		![image-20210705110433863](.\image\image-20210705110433863.png)

![image-20210705110505341](.\image\image-20210705110505341.png)

##### mov、add、sub指令

```text
(1)将数据直接送入寄存器;
(2)将一个寄存器中的内容送入另一个寄存器中。
(3) mov指令还可以将一个内存单元中的内容送入一个寄存器，或者将寄存器中的数据写入内存单元
```


​	 mov 寄存器，数据 

​	 mov 寄存器，寄存器

​	 mov 寄存器，内存单元

​	 mov 内存单元，寄存器

​	 mov 段寄存器，寄存器

##### 栈

​	栈是一种具有特殊的访问方式的存储空间。它的特殊性就在于，最后进入这个空间的数据，最先出去。

​		栈有两个基本的操作：入栈和出栈。

​	入栈：将一个新的元素放到栈顶；

​	出栈：从栈顶取出一个元素。

​	栈顶的元素总是最后入栈，需要出栈时，又最先被从栈中取出。

​	栈的操作规则：LIFO

 （Last In First Out，后进先出）



​	8086CPU提供入栈和出栈指令： （最基本的）

​    	 PUSH（入栈）

   	  POP （出栈）
   	
   	push ax：将寄存器ax中的数据送入栈中；
   	
   	pop ax ：从栈顶取出数据送入ax。

​	8086CPU的入栈和出栈操作都是以字为单位进行的。



CPU如何指导当前要执行的指令所在的位置？

​		寄存器CS和IP中存放着当前指令的段地址和偏移地址。

　	8086CPU中，有两个寄存器：

 		段寄存器SS 　存放栈顶的段地址
 	
 		寄存器SP   存放栈顶的偏移地址
 	
 		任意时刻，SS:SP指向栈顶元素。

##### push 指令的执行过程

![image-20210706082748743](.\image\image-20210706082748743.png)

##### pop 指令的执行过程

​		（1）将SS:SP指向的内存单元处的数据送入ax中；

​		（2）SP = SP+2，SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶。



​	![image-20210706082904822](.\image\image-20210706082904822.png)



###### 注意：

​		出栈后，SS:SP指向新的栈顶 1000EH，pop操作前的栈顶元素，1000CH 处的2266H 依然存在 ，但是，它已不在栈中。当再次		执行push等入栈指令后，SS:SP移至1000CH，并在里面写入新的数据，它将被覆盖。





##### 栈顶超界的问题

​		SS和SP只记录了栈顶的地址，依靠SS和SP可以保证在入栈和出栈时找到栈顶。

​		可是，如何能够保证在入栈、出栈时，栈顶不会超出栈空间？

​			当栈满的时候再使用push指令入栈，

   		栈空的时候再使用pop指令出栈，
   	
   		都将发生栈顶超界问题。





​	8086CPU的工作机理，只考虑当前的情况：

​	当前栈顶在何处；

​	当前要执行的指令是哪一条



#### push、pop指令

​		push和pop指令是可以在寄存器和内存之间传送数据的。

​		push和pop指令的格式

​	

​		push和pop指令的格式（1）

​				push 寄存器：将一个寄存器中的数据入栈

​				pop寄存器：出栈，用一个寄存器接收出栈的数据

​					例如：	  

​								 push ax

 						  	   pop bx

​				push和pop指令的格式（2）

​				push 段寄存器：将一个段寄存器中的数据入栈

​				pop段寄存器：出栈，用一个段寄存器接收出栈的数据

​					例如：

​								 push ds

​      							pop es

​			

​				push和pop指令的格式（3）

​				push内存单元：将一个内存单元处的字入栈（栈操作都是以字为单位）

​				pop 内存单元：出栈，用一个内存字单元接收出栈的数据

​					例如：

​								push [0]

​       						pop [2]

  			指令执行时 ，CPU 要知道内存单元的地址，可以在 push、pop 指令中给出内存单元的偏移地址，段地址在指令执行时，				CPU从ds中取得。





问题1：

​	将10000H~1000FH 这段空间当作栈，初始状态是空的，将 AX、BX、DS中的数据入栈。



​			![image-20210706091951670](.\image\image-20210706091951670.png)



问题2：

（1）将10000H~1000FH 这段空间当作栈，初始状态是空的；

（2）设置AX=001AH，BX=001BH；

（3）将AX、BX中的数据入栈；

（4）然后将AX、BX清零；

（5）从栈中恢复AX、BX原来的内容。







![image-20210706110358372](.\image\image-20210706110358372.png)



![image-20210706110407801](.\image\image-20210706110407801.png)





用栈来暂存以后需要恢复的寄存器中的内容时 ，出栈的顺序要和入栈的顺序相反，因为最后入栈的寄存器的内容在栈顶 ，所以在恢复时，要最先出栈



#### 栈操作机制

push、pop 实质上就是一种内存传送指令，可以在寄存器和内存之间传送数据，与mov指令不同的是，push和pop指令访问的内存单元的地址不是在指令中给出的，而是由SS:SP指出的。

同时，push和pop指令还要改变 SP 中的内容。





push和pop指令同mov指令不同，CPU执行mov指令只需一步操作，就是传送，而执行push、pop指令却需要两步操作。

执行push时：

先改变SP，后向SS:SP处传送。

执行pop时：

先读取SS:SP处的数据，后改变SP



push和pop指令同mov指令不同，CPU执行mov指令只需一步操作，就是传送，而执行push、pop指令却需要两步操作。

执行push时：

​	先改变SP，后向SS:SP处传送。

执行pop时：

​	先读取SS:SP处的数据，后改变SP。



push、pop 等栈操作指令，修改的只是SP。也就是说，栈顶的变化范围最大为：0~FFFFH。

提供：SS、SP指示栈顶；改变SP后写内存的入栈指令；读内存后改变SP的出栈指令。

这就是8086CPU提供的栈操作机制。

#### 栈段

​	将一段内存当作栈段，仅仅是我们在编程时的一种安排，CPU 并不会由于这种安排，就在执行push、pop 等栈操作指令时就自动地将我们定义的栈段当作栈空间来访问。

一个栈段的容量最大为64KB

我们可以将一段内存定义为一个段，用一个段地址指示段，用偏移地址访问段内的单元。这完全是我们自己的安排。

我们可以用一个段存放数据，将它定义为“数据段”；

我们可以用一个段存放代码，将它定义为“代码段”；

我们可以用一个段当作栈，将它定义为“栈段”；



若要让CPU按照我们的安排来访问这些段，就要：

对于数据段，将它的段地址放在 DS中，用mov、add、sub等访问内存单元的指令时，CPU就将我们定义的数据段中的内容当作数据段来访问

将它的段地址放在SS中，将栈顶单元的偏移地置放在 SP 中，这样CPU在需要进行栈操作的时候，比如执行 push、pop 指令等，就将我们定义的栈段当作栈空间来用

#### 汇编程序

一个汇编语言程序从写出到最终执行的简要过程:
	编写-->编译-->链接-->执行
可执行文件
	可执行文件中包含两部分内容:
	程序（从原程序中的汇编指令翻译过来的机器码）和数据（源程序中定义的数据)-相关的描述信息（比如:程序有多大、要占多少内	存空间等)
执行可执行文件中的程序

操作系统依照可执行文件中的描述信息，将可执行文件中的机器码和数据加载入内存，并进行相关的初始化（比如：设置CS:IP指向第一条要执行的指令），然后由CPU执行程序



汇编指令

​	 有对应的机器码的指令，可以被编译为机器指令，最终为CPU所执行。

伪指令

​	 没有对应的机器码的指令，最终不被CPU所执行。

谁来执行伪指令呢？

 	伪指令是由编译器来执行的指令，编译器根据伪指令来进行相关的编译工作。

定义一个段

​	segment和ends是一对成对使用的伪指令，这是在写可被编译器编译的汇编程序时，必须要用到的一对伪指令。

​	segment和ends的功能是定义一个段，segment说明一个段开始，ends 说明一个段结束。

​	一个段必须有一个名称来标识，使用格式为：

​    	  段名 segment

   	   段名 ends



一个汇编程序是由多个段组成的，这些段被用来存放代码、数据或当作栈空间来使用。

一个有意义的汇编程序中至少要有一个段，这个段用来存放代码。



##### 程序结束标记

​	End 是一个汇编程序的结束标记，编译器在编译汇编程序的过程中，如果碰到了伪指令 end，就结束对源程序的编译。

​	如果程序写完了，要在结尾处加上伪指令end 。否则，编译器在编译程序时，无法知道程序在何处结束。

​	注意：不要搞混了end和ends。

#### 寄存器与段的关联假设

​	assume：含义为“假设”。

​	它假设某一段寄存器和程序中的某一个用 segment … ends 定义的段相关联。

​	通过assume说明这种关联，在需要的情况下 ，编译程序可以将段寄存器和某一个具体的段相联系。

#### 源程序

​	

源程序中的“程序”

汇编源程序：

​       伪指令  （编译器处理）

​       汇编指令（编译为机器码）



程序：源程序中最终由计算机执行、处理的指令或数据。

##### 注意

源程序中的“程序”

汇编源程序：

​       伪指令  （编译器处理）

​       汇编指令（编译为机器码）



程序：源程序中最终由计算机执行、处理的指令或数据。

##### 程序经编译连接后变为机器码

![image-20210708132410585](.\image\image-20210708132410585.png)

##### 标号

​	一个标号指代了一个地址。

​	codesg：放在segment的前面，作为一个段的名称，这个段的名称最终将被编译、连接程序处理为一个段的段地址。

##### 程序的结构

​	任务：编程运算 2∧3。

​	定义一个段

​	实现处理任务

​	程序结束

​	段与段寄存器关联



​	汇编程序

​			  assume cs:abc

​			  abc segment

​			  mov ax,2

​			  add ax,ax

​			  add ax,ax

 			 abc ends

​			  end 

##### 程序返回

​		应该在程序的末尾添加返回的程序段。

  		mov ax,4c00H
  	
  		int 21H

​		这两条指令所实现的功能就是程序返回



##### 段结束、程序结束、程序返回

、	![image-20210708133118655](.\image\image-20210708133118655.png)







####  语法错误和逻辑错误

语法错误
   程序在编译时被编译器发现的错误

逻辑错误
   程序在编译时不能表现出来的、在运行时发生的错误

####    程序执行的过程

 一个汇编语言程序从写出到最终执行的简要过程：



#### 连接

##### 作用

当源程序很大时，可以将它分为多个源程序文件来编译，每个源程序编译成为目标文件后，再用连接程序将它们连接到一起，生成一个可执行文件；
程序中调用了某个库文件中的子程序，需要将这个库文件和该程序生成的目标文件连接到一起，生成一个可执行文件；
一个源程序编译后，得到了存有机器码的目标文件，目标文件中的有些内容还不能直接用来生成可执行文件，连接程序将这此内容处理为最终的可执行信息。
所以，在只有一个源程序文件，而又不需要调用某个库中的子程序的情况下，也必须用连接程序对目标文件进行处理，生成可执行文件。
注意，对于连接的过程，可执行文件是我们要得到的最终结果。
使用汇编语言编译程序对源程序文件中的源程序进行编译，产生目标文件；再用连接程序对目标文件进行连接，生成可在操作系统中直接运行的可执行文件。

#### 可执行文件

可执行文件中包含两部分内容：
   程序（从原程序中的汇编指令翻译过来的机器码）和数据（源程序中定义的数据）
   相关的描述信息（比如：程序有多大、要占多少内存空间等）
执行可执行文件中的程序
   在操作系统中，执行可执行文件中的程序。
   操作系统依照可执行文件中的描述信息，将可执行文件中的机器码和数据加载入内存，并进行相关的初始化（比如：设置CS:IP指向第一条要执行的指令），然后由CPU执行程序。

可执行文件中的程序装入内存并运行的原理
   在DOS中，可执行文件中的程序P1若要运行，必须有一个正在运行的程序P2 ，将 P1 从可执行文件中加载入内存，将CPU的控制权交给它，P1才能得以运行；
   当P1运行完毕后，应该将CPU的控制权交还给使它得以运行的程序P2

##### exe的执行过程

​    实际过程
​     （1）我们在提示符“C:\masm”后面输入可执行文件的名字“1”，按Enter键。

​	  （2）1.exe中的程序运行；

​	  （3）运行结束，返回，再次显示提示符“C:\masm”。

#### 操作过程

操作系统是由多个功能模块组成的庞大 、复杂的软件系统。任何通用的操作系统 ，都要提供一个称为shell（外壳）的程序 ，用户（操作人员）使用这个程序来操作计算机系统工作。
DOS中有一个程序command.com ，这个程序在 DOS 中称为命令解释器，也就是DOS系统的shell。
 （1）我们在DOS中直接执行 1.exe 时，是正在运行的command将1.exe中的程序加载入内存。
 （2）command设置CPU的CS:IP指向程序的第一条指令（即程序的入口），从而使程序得以运行。
 （3）程序运行结束后，返回到command中，CPU继续运行command。

####  程序执行过程的跟踪

Debug 可以将程序加载入内存，设置CS:IP指向程序的入口，但Debug并不放弃对CPU 的控制，这样，我们就可以使用Debug 的相关命令来单步执行程序 ，查看每条指令指令的执行结果。

我们在 DOS中用 “Debug 1.exe” 运行Debug对1.exe进行跟踪时，程序加载的顺序是：command加载Debug，Debug加载1.exe。

返回的顺序是：从1.exe中的程序返回到Debug，从Debug返回到command。

EXE文件中的程序的加载过程

![img](https://img-blog.csdn.net/20180915222357916?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hjMTE1MTMxMDEwOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)



#### LOOP指令



```Assembly
assume cs:code     #assume建立段寄存器 段寄存器是CS、DS、ES、SS、FS和GS，段名是在段定义语句说明时的段名   CS对应于代码段code 

code segment		#定义code代码段
	mov ax,2
	mov cx,11		#定义循环次数
s:	add ax,ax  		#s:标识号
	loop s
	
	mov ax,4c00h
	int 21h
code ends			#段名+ ends 表示一个段的结束
end
```



程序分析： 

（1）标号
 在汇编语言中，标号代表一个地址，此程序中有一个标号s 。它实际上标识了一个地址，这个地址处有一条指令：add ax,ax。

（2）loop s

  CPU 执行loop s的时候，要进行两步操作：

  ① (cx)=(cx)-1；

  ② 判断cx 中的值，不为0 则转至标号s 所标识的地址处执行(这里的指令是“add ax,ax)，如果为零则执行下一条指令(下一条指令是mov ax,4c00h)。



cx和loop 指令相配合实现循环功能的三个要点：

（1）在cx中存放循环次数；

（2）loop 指令中的标号所标识地址要在前面；

（3）要循环执行的程序段，要写在标号和loop 指令的中间。

#### and和or指令

​	 and指令 	:	  逻辑与指令，按位进行与运算。
​	如：

​		mov al,01100011B
​		and al,00111011B

​	执行后al = 00100011B

​	通过该指令可将操作对象的相应位设为0，其他位不变。例如:	al = 1111 1111B
​		将al的第6位设为0:and al,1011 1111B
​		将al的第7位设为0:and al,0111 1111B将al的第0位设为0:and al,1111 1110B

​		同c语言里面的"&"

​	or指令:逻辑或指令，按位进行或运算
​	如：

​		mov al, 01100011B
​		or al, 00111011B

​		执行后al = 01111011B

通过该指令可将操作对象的相应位设为1，其他位不变。例如:	al = 0000 0000B

将al的第6位设为1:and al,0100 0000B

将al的第7位设为1:and al,1000 0000B

将al的第0位设为1:and al,1111 1110B



#### [bx+idata]

在前面，我们可以用[bx]的方式来指明一个内存单元，我们还可以用一种更为灵活的方式来指明内存单元:

[bx+idata]表示一个内存单元，它的偏移地址为(bx)+idata( bx中的数值加上idata) 。

我们看一下指令mov ax,[ bx+200]的含义:
	将一个内存单元的内容送入ax，这个内存单元的长度为2字节（字单元），存放一个字，偏移地址为bx中的数值加上200，段地址在ds中。
	数学化的描述为:(ax)=( (ds)*16+(bx)+200)



#### SI和DI

​	SI和DI是8086CPU中和bx功能相近的寄存器，SI和DI不能够分成两个8 位寄存器来使用。

 	 下面的三组指令实现了相同的功能：

​		

​		（1） mov bx,0

​       			mov ax,[bx]

​		（2） mov si,0

​       			mov ax,[si]

​		（3） mov di,0

​       			mov ax,[di]



​	下面的三组指令也实现了相同的功能

​		(1） mov bx,0

​      		 mov ax,[bx+123]

​		(2） mov si,0

   		    mov ax,[si+123]

​		(3） mov di,0

​     		  mov ax,[di+123]

#### 寻址方式

​	(1)[iata]用一个常量来表示地址，可用于直接定位一个内存单元;

​	(2)[ bx]用一个变量来表示内存地址，可用于间接定位一个内存单元;

​	(3)[bx+idata]用一个变量和常量表示地址，可在一个起始地址的基础上用变量间接定位一个内存单元; 

​	(4)[ bx+si]用两个变量表示地址;   

​	(5)[bx+si+idata]用两个变量和一个常量表示地址。



​	直接寻址

​	寄存器间接寻址

​	寄存器相对寻址

​	基址变址寻址
​	相对基址变址寻址

#### bx、si、di、bp

在8086CPU 中，只有这4个寄存器（bx、bp、si、di）可以用在“[…]” 中来进行内存单元的寻址。 

​	正确的指令

​			 mov ax,[bx]

 			mov ax,[bx+si]

​			 mov ax,[bx+di]

​			 mov ax,[bp]

​			 mov ax,[bp+si]

 			mov ax,[bp+di]

#### JMP指令

​			jmp为无条件转移，可以只修改IP，也可以同时修改CS和IP；

​			jmp指令要给出两种信息：

​			转移的目的地址

​			转移的距离（段间转移、段内短转移，段内近转移）

##### 	依据位移进行转移的jmp指令

​			jmp short 标号（转到标号处执行指令）

​	    	这种格式的 jmp 指令实现的是段内短转移，它对IP的修改范围为 -128~127，也就是说，它向前转移时可以最多越过128个字			节，向	后转移可以最多越过127个字节。



​		例：

​			

```assembly
 assume cs:codesg
 codesg segment
	start:	mov ax,0
		  	jmp short s
		  	add ax,1
		  s:inc ax
codesg	ends
end sart
```



​	程序执行后， ax中的值为 1 ，因为执行 jmp short s 后 ，越过了add ax,1 ，IP 指向了标号 s处的 inc ax。也就是说，程序只进行了一	次ax加1操作。



![image-20210710102024136](.\image\image-20210710102024136.png)

​	

​				对照汇编源程序，我们可以看到，Debug 将 jmp short s 中的 s 表示为inc ax 指令的偏移地址 8 ，并将jmp short s 表				示为 jmp 0008 ，表示转移到cs:0008处。

​		指令 “jmp far ptr 标号” 功能如下：

​		(CS)=标号所在段的段地址；

​		(IP)=标号所在段中的偏移地址。

​		far ptr指明了指令用标号的段地址和偏移地址修改CS和IP



jmp short s指令的读取和执行过程:

- ​	(CS)=0BBDH，(IP)=0006，CS:IP指向EB 03 ( jmp short s的机器码
- ​    读取指令码EB 03进入指令缓冲器;
- ​    (IP)=(IP)+所读取指令的长度=(IP)+2=0008，cS:IP指向add ax,1;
- ​    CPu指行指令缓冲器中的指令EB 03;
- ​    指令EB 03执行后，(IP)=000BH，CS :IP指向inc ax。





​	注意︰

​			 要转移的目的地址是cS:000B，而cPu执行EB 03时，当前的(IP)=0008,

​			如果将当前的IP值加3，使(IP)=000BH，CS:IP就可以指向目标指令。 

​			在转移指令EB 03中并没有告诉cPt要转移的目的地址，却告诉了CPU要转移的位移，即将当前的IP向后移动3个字	节。



##### jmp dword ptr内存单元地址(段间转移)

​	功能:从内存单元地址处开始存放着两个字，高地址处的字是转移的目的段地址，低地址处是转移的目的偏移地址。
​	(cs)=(内存单元地址＋2)
​	(工P)=(内存单元地址)
​	内存单元地址可用寻址方式的任一格式给出。

mov ax,0123H
mov ds: [ 0] , ax 
mov word ptr ds : [ 2],0
jmp dword ptr ds: [ 0]

执行后

(cs）=0
(IP)=0123H
cS :IP指向0000:0123



mov ax,0123H 
mov [bx], ax 
mov word ptr [ bx+2],0
jmp dword ptr [bx]

执行后

(cs）=0 
(IP)=0123H 
CS : IP指向0000:0123。



####  原码

原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:

> [+1]原 = 0000 0001
>
> [-1]原 = 1000 0001

第一位是符号位. 因为第一位是符号位, 所以8位二进制数的取值范围就是:

> [1111 1111 , 0111 1111]

即

> [-127 , 127]

原码是人脑最容易理解和计算的表示方式.

#### 反码

反码的表示方法是:

正数的反码是其本身

负数的反码是在其原码的基础上, 符号位不变，其余各个位取反.

> [+1] = [00000001]原 = [00000001]反
>
> [-1] = [10000001]原 = [11111110]反

可见如果一个反码表示的是负数, 人脑无法直观的看出来它的数值. 通常要将其转换成原码再计算.

#### 补码

补码的表示方法是:

正数的补码就是其本身

负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)

> [+1] = [00000001]原 = [00000001]反 = [00000001]补
>
> [-1] = [10000001]原 = [11111110]反 = [11111111]补

对于负数, 补码表示方式也是人脑无法直观看出其数值的. 通常也需要转换成原码在计算其数值.





我们以考虑用8位数据的最高位来表示符号·1表示负·0表示正·其他位用来表示数值。

负数求补码规律:
原码→按位取反→加1得到补码形式



#### jcxz指令

​	jcxz指令为有 条件转移指令，所有的有条件转移指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对IP	的修改范围都为-128~127。

​	指令格式：jcxz 标号 

  （如果(cx)=0，则转移到标号处执行。）



​	jcxz 标号 指令操作：

​	当(cx)=0时，(IP)=(IP)+8位位移）

​	8位位移=“标号”处的地址-jcxz指令后的第一个字节的地址；

​	8位位移的范围为-128~127，用补码表示；

​	8位位移由编译程序在编译时算出。

​	当(cx)=0时，什么也不做（程序向下执行）。

例：

```assembly
assume cs:code
code segment
start:
s:	mov ax, 0	; ax赋值为0
	mov cx, ax	; ax赋值给cx
	inc ax		; ax自增1
	jcxz s		; 判断cx是否为0，当cx=0时，跳转到标号s处
code ends
end start

```



#### loop指令

​	loop指令为循环指令，所有的循环指令都是 短转移 ，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围	都为	-128~127。

​	指令格式：

​	loop 标号

​	 ((cx))=(cx)-1，如果(cx)≠0，转移到标号处执行。



例：

```assembly
assume cs:code
code segment
start:
s:	mov ax, 1	; ax赋值为0
	mov cx, ax	; ax赋值给cx
	loop s		; 判断cx是否为0，当cx=0时，跳转到标号s处
code ends
end start

```



#### 根据位移进行转移的意义

   jmp short 标号

   jmp near ptr 标号

   jcxz 标号

   loop 标号

​	  等几种汇编指令，它们对 IP的修改是根据转移目的地址和转移起始地址之间的位移来进行的。在它们对应的机器码中不包含		转移的目的地址，而包含的食道目的地址的位移。

​	方便程序段在内存中的浮动装配

例:

![image-20210710155022808](.\image\image-20210710155022808.png)



​	这段程序装在内存中的不同位置都可正确执行，因为 loop s 在执行时只涉及到 s的位移（ - 4，前移 4个字节，补码表示为		FCH），而不是s的地址

​	如果loop s的机器码中包含的是s的地址，则就对程序段在内存中的偏移地址有了严格的限制；

​	因为机器码中包含的是 s 的地址，如果 s 处的指令不在目的地址处，程序的执行就会出错。

​	而loop s的机器码中包含的是转移的位移，就不存在这个问题了；

​	因为，无论 s处的指令的实际地址是多少，loop指令的转移位移是不变的

注：

​	根据位移进行转移的指令，它们的转移范围受到转移位移的限制，如果在源程序中出现了转移范围超界的问题，在编译的时	候，编译器将报错

例：

​	下面的程序将引起编译错误



```assembly
 assume cs:code
     code segment
       start: jmp short s
	            db 128 dup(0)
            s: mov ax,0ffffh
     code ends
     end start

```



​	jmp short s的转移范围是-128~127，IP最多向后移动127个字节



#### ret 和 retf

​	call和ret 指令都是转移指令，它们都修改IP，或同时修改CS和IP。

​	ret指令用栈中的数据，修改IP的内容，从而实现近转移

​	

​	CPU执行ret指令时，进行下面两步操作:

​	（1）(IP)=((ss)*16+(sp))

​	（2）(sp)=(sp)+2



​	CPU执行retf指令时，进行下面两步操作：

​	（1）(IP)=((ss)*16+(sp))

​	（2）(sp)=(sp)+2

​	（3）(CS)=((ss)*16+(sp))

​	（4）(sp)=(sp)+2



​	用汇编语法来解释ret和retf指令，则：

​	CPU执行ret指令时，相当于进行：

​	 pop IP

​	CPU执行retf指令时，相当于进行：

​	 pop IP

​	 pop CS



#### call 指令

​	CPU执行call指令，进行两步操作：

（1）将当前的 IP 或 CS和IP 压入栈中；

（2）转移。

call 指令不能实现短转移，除此之外，call指令实现转移的方法和 jmp 指令的原理相同，下面的几个小节中 ，我们以给出转移目的地址的不同方法为主线，讲解call指令的主要应用格式。



call 标号（将当前的 IP 压栈后，转到标号处执行指令）

CPU执行此种格式的call指令时，进行如下的操作：

(1) (sp) = (sp) – 2

​    ((ss)*16+(sp)) = (IP)

(2) (IP) = (IP) + 16位位移



call 标号

16位位移=“标号”处的地址－call指令后的第一个字节的地址；

16位位移的范围为 -32768~32767，用补码表示；

16位位移由编译程序在编译时算出。



##### 依据位移进行转移的call指令

​	用汇编语法来解释此种格式的 call指令，则：

  	CPU 执行指令“call 标号”时，相当于进行：

​		    push IP

​		    jmp near ptr 标号      



##### 转移的目的地址在指令中的call指令

​		前面的call指令，其对应的机器指令中并没有转移的目的地址 ，而是相对于当前IP的转移位移。

​		指令“call far ptr 标号”实现的是段间转移。

​		

​	CPU执行“call far ptr 标号”这种格式的call指令时的操作：

​	(1) (sp) = (sp) – 2

   	 ((ss) ×16+(sp)) = (CS)

​    	(sp) = (sp) – 2

​    	((ss) ×16+(sp)) = (IP)

​	(2) (CS) = 标号所在的段地址

  		(IP) = 标号所在的偏移地址



​	用汇编语法来解释此种格式的 call 指令，则：

  	CPU 执行指令 “call far ptr 标号” 时，相当于进行：

​    	push CS

​     	push IP

​     	jmp far ptr 标号



##### 转移地址在寄存器中的call指令

​	指令格式：call 16位寄存器

​	功能：

​	(sp) = (sp) – 2

​	((ss)*16+(sp)) = (IP)

​	(IP) = (16位寄存器) 

​	n指令格式：call 16位寄存器



​	汇编语法解释此种格式的 call 指令，CPU执行call 16位reg时，相当于进行：

​     push IP 

​      jmp 16位寄存器



#### 转移地址在内存中的call指令

​	转移地址在内存中的call指令有两种格式：

​	(1) call word ptr 内存单元地址

​	 (2) call dword ptr 内存单元地址

​	

​		call word ptr 内存单元地址

​		汇编语法解释：

   			push IP
   	
   			 jmp word ptr 内存单元地址





​		call word ptr 内存单元地址（示例）

​		比如下面的指令：

 		mov sp,10h
 	
 		mov ax,0123h
 	
 		mov ds:[0],ax
 	
 		call word ptr ds:[0]

​		执行后，(IP)=0123H，(sp)=0EH



​		call dword ptr 内存单元地址

​		汇编语法解释：

​      	push CS

  		push IP

​	  	jmp dword ptr 内存单元地址

#### mul 指令

​	mul是乘法指令，使用 mul 做乘法的时候：

​	1)相乘的两个数：要么都是8位，要么都是16位。

   8 位： AL中和 8位寄存器或内存字节单元中；

  16 位： AX中和 16 位寄存器或内存字单元中。

​	n使用mul座乘法的时候：

n(2)结果

   8位：AX中；

  16位：DX（高位）和AX（低位）中。

​	

​	格式如下：

​		  mul reg

​		  mul 内存单元



n内存单元可以用不同的寻址方式给出，比如：

nmul byte ptr ds:[0]

 含义为： (ax)=(al)*((ds)*16+0)；



​	mul word ptr [bx+si+8]

 	 含义为： 

​	  (ax)=(al)*((ds)*16+(bx)+(si)+8)结果的低16位；

​	  (dx)=(al)*((ds)*16+(bx)+(si)+8)结果的高16位；

​	

例：	

​	计算100*10

  	100和10小于255，可以做8位乘法，程序如下：

​	    mov al,100

​	     mov bl,10

​	     mul bl

   结果： (ax)=1000（03E8H） 



​	计算100*10000

 	 100小于255，可10000大于255，所以必须做16位乘法，程序如下：
 	
 	   mov ax,100
 	
 	    mov bx,10000

​	     mul bx

​	   结果： (ax)=4240H，(dx)=000FH

​      	  （F4240H=1000000）

#### 模块化程序设计

​	 call与ret指令共同支持了汇编语言编程中的模块化设计。
​	在实际编程中，程序的模块化是必不可少的。

​	因为现实的问题比较复杂，对现实问题进行分析时，
​	把它转化成为相互联系、不同层次的子问题，是必须的解决方法。

​	而call和ret指令对这种分析方法提供了程序实现上的支持。利用call和ret指令
​	我们可以用简洁的方法，实现多个互相联系、功能独立的子程序来解决一个复杂的问题。





#### 参数和结果传递的问题

子程序一般都要根据提供的参数处理一定的事务，
	处理后，将结果(返回值)提供给调用者。

​	其实，我们讨论参数和返回值传递的问题，实际上就是在探讨，
​		应该如何存储子程序需要的参数和产生的返回值。

我们设计一个子程序，可以根据提供的N，来计算N的3次方。
		这里有两个问题:
			我们将参数N存储在什么地方?
			计算得到的数值，我们存储在什么地方

子程序:
		说明:计算N的3次方

​		参数:

​				(bx)=N

​		结果:

​				(dx : ax)=N^3
​				cube : mov ax , bxmul bx
​				mul bxretl